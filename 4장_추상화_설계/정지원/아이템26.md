# 아이템 26 : 함수 내부의 추상화 레벨을 통일하라

### 추상화 레벨 통일

코드도 추상화를 계층처럼 만들어서 사용할 수 있다. → 함수를 사용

함수도 높은 레벨과 낮은 레벨을 구분해서 사용해야 하는 원칙이 있다. 이를 SLA(추상화 레벨 통일)원칙이라고 부른다.

```kotlin
SLA(Single Level of Abstraction)
```

버튼 하나만 누르면 커피를 만들 수 있는 커피 머신을 나타내는 클래스를 만들어보자.

```kotlin
class CoffeeMachine {
    fun makeCoffee() {
        // 수백 개의 변수와, 복잡한 로직, 낮은 수준의 최적화 포함
    }
}
```

위 처럼 코드를 작성한다면, `makeCoffee` 함수가 커지게 되고, 세부적인 내용을 하나씩 신경 써야 하므로, 읽고 이해하는 것이 힘들다.

만약 코드를 수정해달라는 요청사항이 들어왔다면? 어디 부분을 수정해야 하는지 힘들 것이다.

```kotlin
class CoffeeMachine {
    fun makeCoffee() {
        boilWater()
        brewCoffee()
        pourCoffee()
        pourMilk()
    }

    private fun boilWater() { ... }
    ...
    ...
}
```

다음과 같이 함수를 계층처럼 나누어서 사용한다면 어떤 식으로 당작하는지 확실하게 확인할 수 있다.

`makeCoffee()` 함수는 읽고 이해하기 쉽다. 낮은 레벨의 함수(`boilWater()` , `brewCoffee()`)를 이해해야 한다면, 해당 부분의 코드만 살펴보면 된다. 위 코드에서 알아 볼 수 있는 점은

- 매우 간단한 추상화를 추출하여 가독성을 크게 향상
- 함수는 작고 최소한의 책임만 가질 것
- 재사용과 테스트에 용이

또한 어떤 함수가 다른 함수보다 복잡하다면 일부 부분을 추출해서 추상화 하는 것이 좋다.

### 프로그램 아키텍처의 추상 레벨

추상화를 구분하는 이유는 서브시스템의 세부 사항을 숨김으로써 상호 운영성, 플랫폼 독립성을 얻기 위함이다.→ 문제 중심으로 프로그래밍

4 높은 레벨 문제 중심 |
| --- |
3 낮은 레벨 문제 중심 |
2 낮은 레벨 구현 구조 |
1 프로그래밍 언어 구조와 도구 |
0 운영 체제 연산과 머신 명령 |

이러한 개념은 모듈 시스템을 설계할 때도 중요하다. 모듈을 분리하고, 계층 고유의 요소를 숨길 수 있다.

```kotlin
입, 출력을 나타내는 모듈(UI)은 낮은 레벨의 모듈, 비즈니스 로직을 나타내는 부분은 높은 레벨의 모듈이다.
```

계층화가 잘 된 프로젝트는 어떤 계층 위치에서 코드를 보아도, 일관적인 관점을 얻을 수 있다.

### 정리

- 별도의 추상화 계층을 만드는 것은 knowledge를 체계화하고, 서브시스템의 세부 사항을 숨김으로 상호 운영성과 플랫폼 독립성을 얻게 한다.
- 함수, 클래스, 모듈 등 다양한 방식을 통해 추상화를 분리한다.
- 추상화 레벨은 구체적인 동작, 프로세서, 입출력과 가까울수록 낮은 레벨이라고 표현한다.
- 낮은 추상화 계층에선 높은 계층에서 사용하는 API를 만든다.
